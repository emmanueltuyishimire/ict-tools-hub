
export const faqData = [
    { question: "What is a query execution plan?", answer: "An execution plan is the sequence of steps that a database's query optimizer decides to use to access data for a SQL query. It's like a roadmap, detailing whether to use an index, what order to join tables in, etc. The `EXPLAIN` command in SQL shows you this plan." },
    { question: "What is the difference between a Full Table Scan and an Index Scan?", answer: "A Full Table Scan reads every single row in a table to find the ones that match a query's condition. An Index Scan uses a pre-sorted index (like a B-Tree) to directly locate the required rows without reading the whole table. For large tables, an index scan is exponentially faster for finding a small number of rows." },
    { question: "Why is an 'Indexed Read' so much faster?", answer: "Because it avoids costly disk I/O. Instead of reading the entire table from disk, the database only needs to perform a few random reads to traverse the index and then fetch the specific data pages it needs. This reduces the amount of data read from disk by several orders of magnitude." },
    { question: "What is IOPS and why does it matter?", answer: "IOPS (Input/Output Operations Per Second) measures how many read/write operations a disk can perform per second. It's a key metric for random-access workloads like indexed database reads. SSDs have vastly higher IOPS than HDDs, which is why they are critical for database performance. You can learn more with our <a href='/tools/iops-calculator' class='text-primary hover:underline'>IOPS Calculator</a>." },
    { question: "Does caching affect query time?", answer: "Massively. If the data a query needs is already in the database's RAM cache (from a previous query), it can skip the disk I/O step entirely, making the query much faster. This simulation primarily models the 'worst-case' scenario of reading from disk." },
    { question: "How can I find out if my real query is using an index?", answer: "Use the `EXPLAIN` (or `EXPLAIN ANALYZE` in PostgreSQL) command. Prepend it to your SQL query. The database will return the execution plan it chose. Look for terms like 'Index Scan' or 'Index Seek' (good) versus 'Seq Scan' or 'Table Scan' (bad for large tables)." },
    { question: "Why do you only need to read a small number of rows for an indexed read?", answer: "An index allows the database to pinpoint the exact rows it needs. For example, in `WHERE status = 'active'`, if only 100 rows have that status, an index on the `status` column allows the database to find and read only those 100 rows, even in a billion-row table." },
    { question: "Is this calculator accurate?", answer: "This is a conceptual tool to demonstrate the performance difference between access methods. Real-world query time is incredibly complex and depends on the specific database engine, hardware, caching, and query complexity. This tool provides a simplified model for educational purposes." },
    { question: "What's the difference between CPU time and I/O time?", answer: "I/O (Input/Output) time is the time spent waiting to read data from or write data to the disk, which is a relatively slow mechanical process. CPU time is the time spent actively processing the data once it's in memory. For many database queries, I/O time is the dominant bottleneck." },
    { question: "Why are indexes called B-Trees?", answer: "B-Tree (Balanced Tree) is the most common data structure used to implement database indexes. It's a self-balancing tree that keeps data sorted and allows for searches, insertions, and deletions in logarithmic time, which is extremely efficient." }
];

export const howToSchema = {
    '@context': 'https://schema.org',
    '@type': 'HowTo',
    name: 'How to Use the Query Execution Time Estimator',
    description: 'A guide to understanding the factors that influence database query speed.',
    step: [
        { '@type': 'HowToStep', name: 'Step 1: Set System Parameters', text: 'Enter the total number of rows in your table and select the speed of your underlying disk storage (e.g., SSD or HDD).' },
        { '@type': 'HowToStep', name: 'Step 2: Define Your Query', text: 'Choose the query type (`Indexed Read` or `Full Table Scan`) and specify how many rows the query needs to read and return.' },
        { '@type': 'HowToStep', name: 'Step 3: Analyze the Estimate', text: 'The tool will provide a conceptual execution time, broken down into Disk I/O time and CPU processing time. Compare the results for a full scan vs. an indexed read on a large table to see the importance of indexing.' },
    ],
    totalTime: 'PT1M'
};

export const keyTerminologies = [
    { term: 'Query Execution Plan', definition: 'The set of steps generated by a database\'s query optimizer to execute a SQL query in the most efficient way possible.' },
    { term: 'Full Table Scan', definition: 'A database operation that reads every single row in a table to find the ones that match the query conditions. It is very inefficient for large tables.' },
    { term: 'Index Scan (or Seek)', definition: 'An operation that uses a database index (like a B-Tree) to directly locate and retrieve specific rows without reading the entire table.' },
    { term: 'IOPS (Input/Output Operations Per Second)', definition: 'A measure of storage performance, indicating how many read/write operations a disk can perform per second. Crucial for random-access workloads like indexed reads.' },
    { term: 'Database Cache (Buffer Pool)', definition: 'A portion of RAM that the database uses to store frequently accessed data pages, avoiding slow reads from disk.' },
    { term: '`EXPLAIN` Command', definition: 'A SQL command that shows the execution plan for a query, revealing whether it will use an index or perform a full table scan.' }
];
